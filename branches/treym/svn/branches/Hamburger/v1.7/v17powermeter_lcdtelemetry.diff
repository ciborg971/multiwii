--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/meineCombi-7-v1-7/MultiWiiV1_7_configAbort_TRI60/MultiWiiV1_7_configAbort_TRI60.pde	2011-04-16 18:13:23.000000000 +0200
+++ /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/meineCombi-7-v1-7/MultiWiiV1_7_powermeter_TRI60/MultiWiiV1_7_powermeter_TRI60.pde	2011-04-26 19:11:37.000000000 +0200
@@ -158,8 +158,39 @@
 #define TRI_YAW_CONSTRAINT_MAX 2000
 #define TRI_YAW_MIDDLE 1500
 
+/* to sum the power consumption from battery it is possible to sum up the signals sent to each ESC separately. */
+/* Under the asumption that a) the function from ESC signal to consumed power  quite follows a universal characteristic function */
+/* and b) the time base i.e. main loop time is quite stable and known */
+/* it will be possible to derive a value that corresponds to total consumed power */
+//#define POWERMETER
+// the sum of all powermeters ranges from [0:60000 e4] theoretically.
+// the alarm level from eeprom is out of [0:255], so we multipy alarm level with PLEVELSCALE and with 1e4 before comparing
+// the default value should be fine; for a 1000mAh battery on my TRI it gives an step size of ~10mAh to define alarm level
+// how to find your plevelscale for your particular copter and particular battery range in 3 easy steps
+// only neccesssary if you get overrun or feel adventurous:
+  // 1 fly copter, at end of flight use LCD and read the sum value (example 8040 for 1000mAh battery)
+  // 2 optional: charge battery and memorize mAh (example: 930mAh)
+  // 3 divide sum value by 255, add 30% margin (example: 8040/255 = 31; add 30% margin => 40)
+// defaults should be fine - only touch if you know what you are doing
+#define PLEVELSCALE 100 
+#define PLEVELDIV 10000
+
+/* to monitor system values (battery level, loop time etc. with LCD enable this */
+/* note: for now you must send single characters 'A', 'B', 'C', 'D' to request 4 different screens */
+/* New: the info screen on the LCD does get updated automatically - for stop press same button again */
+/* easy to use with Textstar LCD - the 4 buttons are preconfigured to send 'A', 'B', 'C', 'D' */
+//#define LCD_TELEMETRY
+/* on page B it gives a bar graph which shows how much voltage battery has left. Range from 0 to 12 Volt is not very informative */
+/* so we try do define a meaningful part. For a 3S battery we define full=12,6V and calculate how much it is above first warning level */
+/* Example: 12.6V - VBATLEVEL1_3S  (for me = 126 - 102 = 24) */
+#define VBATREF 24 
+
+/* to log values like max loop time and others to come, we need extra variables */
+/* if you do not want the additional computing time or are short on memory, then comment the following */
+#define LOG_VALUES
+
 //****** end of advanced users settings *************
-#include "/Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/meineCombi-7-v1-7/TRI60.h"
+
 /**************************************/
 /****END OF CONFIGURABLE PARAMETERS****/
 /**************************************/
@@ -171,6 +202,8 @@
 #define V_BATPIN 3    // Analog PIN 3
 #define STABLEPIN     // will be defined for MEGA in a future version
 
+#include "/Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/meineCombi-7-v1-7/TRI60.h"
+
 #if defined(PROMINI)
   #define LEDPIN_PINMODE             pinMode (13, OUTPUT);
   #define LEDPIN_SWITCH              PINB |= 1<<5;     //switch LEDPIN state (digital PIN 13)
@@ -295,6 +328,9 @@
 static uint32_t rcTime;
 static uint32_t currentTime;
 static uint16_t cycleTime;          // this is the number in micro second to achieve a full loop, it can differ a little and is taken into account in the PID loop
+#ifdef LOG_VALUES
+static uint16_t cycleTimeMax = 0;          // highest ever cycle timen 
+#endif
 static uint16_t meanTime = 2000;    // this is the average time of the loop: around 2ms for a WMP config and 6ms for a NK+WMP config
 static uint16_t calibratingA;       // the calibration is done is the main loop. Calibrating decreases at each cycle down to 0, then we enter in a normal mode.
 static uint16_t calibratingG;
@@ -316,7 +352,20 @@
 static int16_t altitudeSmooth = 0;
 static uint8_t calibratedACC = 0;
 static uint8_t vbat;               //battery voltage in 0.1V steps
-
+#if defined(POWERMETER)
+#ifndef VBAT
+	#error "to use powermeter, you must also define and configure VBAT"
+#endif
+static uint32_t pMeter[7]; //we use [0:5] for six motors,[6] for sum
+static uint8_t pMeterV; // dummy to satisfy the paramStruct logic in ConfigurationLoop()
+static uint32_t pAlarm; // we scale the eeprom value from [0:255] to this value we can directly compare to the sum in pMeter[6]
+#define PARAMMAX 25
+#define PARAMMOTORSTART  16
+#define PARAMMOTOREND    24
+#define PARAMMOTOROFFSET 17
+#else
+#define PARAMMAX 16
+#endif
 // *********************
 // I2C general functions
 // *********************
@@ -1531,6 +1580,9 @@
 static uint8_t checkNewConf = 134;
 static uint8_t activateAcc8,activateBaro8,activateMag8;
 static uint8_t activateCamStab8,activateCamTrig8;
+#if defined(POWERMETER)
+static uint8_t powerTrigger1=0; // trigger for alarm based on power consumption
+#endif
 
 void readEEPROM() {
   uint8_t i,p=1;
@@ -1543,6 +1595,10 @@
   activateAcc8 = EEPROM.read(p++);activateBaro8 = EEPROM.read(p++);activateMag8 = EEPROM.read(p++);
   activateCamStab8 = EEPROM.read(p++);activateCamTrig8 = EEPROM.read(p++);
   for(i=0;i<3;i++) accZero[i] = (EEPROM.read(p++)&0xff) + (EEPROM.read(p++)<<8);
+  #if defined(POWERMETER)
+  powerTrigger1 = EEPROM.read(p++);
+  pAlarm = (uint32_t) powerTrigger1 * (uint32_t) PLEVELSCALE * (uint32_t) PLEVELDIV; // need to cast before multiplying
+  #endif
   //note on the following lines: we do this calcul here because it's a static and redundant result and we don't want to load the critical loop whith it
   rcFactor1 = rcRate8/50.0*rcExpo8/100.0/250000.0;
   rcFactor2 = (100-rcExpo8)*rcRate8/5000.0;
@@ -1560,6 +1616,9 @@
   EEPROM.write(p++,activateAcc8);EEPROM.write(p++,activateBaro8);EEPROM.write(p++,activateMag8);
   EEPROM.write(p++,activateCamStab8);EEPROM.write(p++,activateCamTrig8);
   for(i=0;i<3;i++) {EEPROM.write(p++,accZero[i]);EEPROM.write(p++,accZero[i]>>8&0xff);}
+  #if defined(POWERMETER)
+  EEPROM.write(p++,powerTrigger1);
+  #endif
   readEEPROM();
   blinkLED(15,20,1);
 }
@@ -1577,6 +1636,7 @@
     dynThrPID = 0;
     activateAcc8 = 0;activateBaro8 = 0;activateMag8 = 0;
     activateCamStab8 = 0;activateCamTrig8 = 0;
+    powerTrigger1 = 0;
     writeParams();
   }
 }
@@ -1627,6 +1687,8 @@
   #endif
 }
 
+
+
 void configurationLoop() {
   uint8_t chan,i;
   uint8_t param,paramActive;
@@ -1651,6 +1713,17 @@
   {"RC RATE", &rcRate8,2,2},       {"RC EXPO", &rcExpo8,2,2},
   {"PITCH&ROLL RATE", &rollPitchRate,2,2}, {"YAW RATE", &yawRate,2,2},
   {"THROTTLE PID", &dynThrPID,2,2},
+#if defined(POWERMETER)
+  {"pMeter Motor 0", &pMeterV,16,0}, //17
+  {"pMeter Motor 1", &pMeterV,16,0}, //18
+  {"pMeter Motor 2", &pMeterV,16,0}, //19
+  {"pMeter Motor 3", &pMeterV,16,0}, //20  
+  {"pMeter Motor 4", &pMeterV,16,0}, //21
+  {"pMeter Motor 5", &pMeterV,16,0}, //22
+  {"pMeter Sum", &pMeterV,16,0}, //23
+  {"pAlarm /100", &powerTrigger1,0,1}, //24
+  {"Battery Volt", &vbat,1,0}, //25
+#endif
   };
 
   initLCD();
@@ -1661,13 +1734,29 @@
       strcpy(line1,"                ");
       i=0; char* point = p[param].paramText; while (*point) line1[i++] = *point++;
       uint16_t unit = *p[param].var;
+      #if defined(POWERMETER)
+      if (param > PARAMMOTORSTART && param < PARAMMOTOREND)
+        // pmeter values need special treatment, too many digits to fit standard 8 bit scheme
+        unit = pMeter[param-PARAMMOTOROFFSET] / PLEVELDIV; // [0:1000] * 1000/3 samples per second(loop time) * 60 seconds *5 minutes -> [0:10000 e4] per motor
+                                            // (that is full throttle for 5 minutes sampling with high sampling rate for wmp only)
+                                            // times 6 for a maximum of 6 motors equals [0:60000 e4] for the sum
+                                            // we are only interested in the big picture, so drop 4 lower digits base 10
+      #endif
       if (param == 12) {unit *=2;} // RC RATE can go up to 500
       char c1 = '0'+unit/100; char c2 = '0'+unit/10-(unit/100)*10; char c3 = '0'+unit-(unit/10)*10;
       if (p[param].decimal == 0) {line2[6] = c1;  line2[7] = c2;   line2[8] = c3;}
       if (p[param].decimal == 1) {line2[5] = c1;  line2[6] = c2;   line2[7] = '.'; line2[8] = c3;}
       if (p[param].decimal == 2) {line2[5] = c1;  line2[6] = '.';  line2[7] = c2;  line2[8] = c3;}
       if (p[param].decimal == 3) {line2[4] = '0'; line2[5] = '.';  line2[6] = c1;  line2[7] = c2; line2[8] = c3;}
-
+      #if defined(POWERMETER) // so far, only used for POWERMETER functionality, but otherwise it is general purpose
+      if (p[param].decimal == 16) { // not 16 digits but a 16 bit unsigned value; so need 5 digits base 10 to represent [0:65535]
+        line2[4] = '0' + unit / 10000;
+        line2[5] = '0' + unit / 1000 - (unit/10000) * 10;
+        line2[6] = '0' + unit / 100  - (unit/1000)  * 10;
+        line2[7] = '0' + unit / 10   - (unit/100)   * 10;
+        line2[8] = '0' + unit        - (unit/10)    * 10;
+      }
+      #endif
       #if defined(LCD_TEXTSTAR)
         LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
         LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
@@ -1679,13 +1768,14 @@
     }
     for (chan = ROLL; chan < 4; chan++) rcData[chan] = readRawRC(chan);
     //switch config param with pitch
-    if (rcData[PITCH] < MINCHECK && paramActive == 0 && param<16) {
+    if (rcData[PITCH] < MINCHECK && paramActive == 0 && param<= PARAMMAX) {
       paramActive = 1;refreshLCD=1;blinkLED(10,20,1);
       param++;
+      if (param>PARAMMAX) param=0;
     }
-    if (rcData[PITCH] > MAXCHECK && paramActive == 0 && param>0) {
+    if (rcData[PITCH] > MAXCHECK && paramActive == 0 && param>=0) {
       paramActive = 1;refreshLCD=1;blinkLED(10,20,1);
-      param--; 
+      if (param==0) param=PARAMMAX; else param--;
     }
     if (rcData[PITCH] < MAXCHECK && rcData[PITCH] > MINCHECK)  paramActive = 0;
     //+ or - param with low and high roll
@@ -1730,13 +1820,15 @@
   }
 }
 
+/* need this global to have access in serial monitor */
+static uint32_t vbatRaw = 0;       //used for smoothing voltage reading
+  
 void annexCode() { //this code is excetuted at each loop and won't interfere with control loop if it lasts less than 650 microseconds
   static uint32_t serialTime;
   static uint32_t buzzerTime;
   static uint32_t calibrateTime;
   static uint32_t calibratedAccTime;
   static uint8_t  buzzerState = 0;
-  static uint32_t vbatRaw = 0;       //used for smoothing voltage reading
   static uint8_t buzzerFreq;         //delay between buzzer ring
   uint8_t axis;
   uint8_t prop1,prop2;
@@ -1761,9 +1853,19 @@
     vbatRaw = (vbatRaw*15 + analogRead(V_BATPIN)*16)>>4; // smoothing of vbat readings  
     vbat = vbatRaw / VBATSCALE;                          // result is Vbatt in 0.1V steps
      
-    if (vbat>VBATLEVEL1_3S) {
+    if ( (vbat>VBATLEVEL1_3S) 
+    #if defined(POWERMETER)
+                         && ( (pMeter[6] < pAlarm) || (pAlarm == 0) )
+    #endif
+                                                                        )
+    {                                          //VBAT ok AND powermeter ok, buzzer off
       buzzerFreq = 0; buzzerState = 0; BUZZERPIN_OFF;
-    } else if (vbat>VBATLEVEL2_3S)
+    }
+    #if defined(POWERMETER)
+    else if (pMeter[6] > pAlarm)                              // sound alarm for powermeter
+      buzzerFreq = 6;
+    #endif
+    else if (vbat>VBATLEVEL2_3S)
       buzzerFreq = 1;
     else if (vbat>VBATLEVEL3_3S)
       buzzerFreq = 2;
@@ -1855,6 +1957,10 @@
     calibratingA = 0;
   #endif
   calibratingG = 400;
+  #if defined(POWERMETER)
+  for(uint8_t i=0;i<7;i++) // 6 is the maximum number of possible motors, array is larger by one to append the sum
+    pMeter[i]=0; // initialize all counters
+  #endif
 }
 
 // ******** Main Loop *********
@@ -1877,6 +1983,15 @@
   static uint8_t camState = 0;
   static uint32_t camTime,magTime;
   static uint8_t rcOptions;
+  #if defined(POWERMETER)
+  uint32_t amp;
+  /* real square function */
+  /* const uint32_t amperes[16] = {3, 15, 34, 62, 97, 140, 191, 250, 315, 389, 472, 562, 659, 765, 879, 1000 };*/
+  /* experimentall curve (above square curve for values > 50%) */
+  /* const uint32_t amperes[16] =   {3, 16, 34, 53, 92, 145, 224, 309, 382, 461, 566, 671, 789, 882, 941, 1000 }; */
+  /* true cubic function; when divided by vbat_max=126 (12.6V) for 3 cell battery this gives maximum value of ~ 1000 */
+  const uint32_t amperes[16] =   {31, 246, 831, 1969, 3845, 6645, 10551, 15750, 22425, 30762, 40944, 53156, 67583, 84410, 103821, 126000 };
+  #endif
 
   if (currentTime > (rcTime + 20000) ) { // 50Hz
     computeRC();
@@ -1943,6 +2058,10 @@
         rcDelayCommand = 0;
       }
     }
+    #ifdef LOG_VALUES
+      else // update max value here, so do not get cycle time of the motor arming (which is way higher than normal)
+        if ( (cycleTime > cycleTimeMax) && armed ) cycleTimeMax = cycleTime; // remember highscore
+    #endif
     rcOptions = (rcData[AUX1]<1300) + (1300<rcData[AUX1] && rcData[AUX1]<1700)*2 + (rcData[AUX1]>1700)*4
                +(rcData[AUX2]<1300)*8 + (1300<rcData[AUX2] && rcData[AUX2]<1700)*16 + (rcData[AUX2]>1700)*32;
     //note: if FAILSAFE is disable, failsafeCnt > 5*FAILSAVE_DELAY is always false
@@ -2041,9 +2160,9 @@
     servo[1]  = constrain(1500 + YAW_DIRECTION * (axisPID[YAW] - axisPID[PITCH]), 1020, 2000); //RIGHT
   #endif
   #ifdef TRI
-    motor[0] = rcCommand[THROTTLE] + axisPID[PITCH]*4/3 ;                 //REAR
-    motor[1] = rcCommand[THROTTLE] - axisPID[ROLL] - axisPID[PITCH]*2/3 ; //RIGHT
-    motor[2] = rcCommand[THROTTLE] + axisPID[ROLL] - axisPID[PITCH]*2/3 ; //LEFT
+    motor[0] = rcCommand[THROTTLE] + axisPID[PITCH]*4/6 ;                 //REAR
+    motor[1] = rcCommand[THROTTLE] - axisPID[ROLL] - axisPID[PITCH]/6 ; //RIGHT
+    motor[2] = rcCommand[THROTTLE] + axisPID[ROLL] - axisPID[PITCH]/6 ; //LEFT
     servo[0] = constrain(TRI_YAW_MIDDLE + YAW_DIRECTION * axisPID[YAW], TRI_YAW_CONSTRAINT_MIN, TRI_YAW_CONSTRAINT_MAX); //REAR
   #endif
   #ifdef QUADP
@@ -2153,6 +2272,18 @@
   #endif
   
   writeMotors();
+  
+  #if defined(POWERMETER)
+  if (vbat) { // by all means - must avoid division by zero 
+    for (uint8_t i =0;i<NUMBER_MOTOR;i++) {
+
+      amp = amperes[(motor[i] - 1000)>>6] / vbat; // range mapped from [1000:2000] => [0:1000]; then break that up into 16 ranges; lookup amp
+      pMeter[i]+= amp; // sum up over time the mapped ESC input 
+                               // this is poor man's integral
+      pMeter[6]+= amp; // total sum over all motors
+    }
+  }
+  #endif
 }
 
 static uint8_t point;
@@ -2181,11 +2312,112 @@
 void serialCom() {
   int16_t a;
   uint8_t i;
+  uint16_t intPowerMeterSum, intPowerTrigger1;    
+#ifdef LCD_TELEMETRY
+  char line1[17],line2[17];
+  static uint8_t telemetry = 0;
+
+  switch (telemetry) { // output telemetry data, if one of four modes is set
+  case 'A': // button A on Textstar LCD -> cycle time
+    strcpy(line1,"Cycle    _____us"); //uin16_t cycleTime
+    /*            0123456789.12345*/
+    strcpy(line2,"CycleMax _____us"); //uin16_t cycleTimeMax
+    line1[9] = '0' + cycleTime / 10000;
+    line1[10] = '0' + cycleTime / 1000 - (cycleTime/10000) * 10;
+    line1[11] = '0' + cycleTime / 100  - (cycleTime/1000)  * 10;
+    line1[12] = '0' + cycleTime / 10   - (cycleTime/100)   * 10;
+    line1[13] = '0' + cycleTime        - (cycleTime/10)    * 10;
+  #ifdef LOG_VALUES
+    line2[9] = '0' + cycleTimeMax / 10000;
+    line2[10] = '0' + cycleTimeMax / 1000 - (cycleTimeMax/10000) * 10;
+    line2[11] = '0' + cycleTimeMax / 100  - (cycleTimeMax/1000)  * 10;
+    line2[12] = '0' + cycleTimeMax / 10   - (cycleTimeMax/100)   * 10;
+    line2[13] = '0' + cycleTimeMax        - (cycleTimeMax/10)    * 10;
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+  #endif
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    break;
+  case 'B': // button B on Textstar LCD -> Voltage, PowerSum and power alarm trigger value
+    strcpy(line1,"__._V "); //uint8_t vbat, uint32_t vbatRaw
+    /*            0123456789.12345*/
+    strcpy(line2,"Psum _____   ___"); // intPowerMeterSum, intPowerTrigger1
+  #ifdef VBAT
+    line1[0] = '0'+vbat/100; line1[1] = '0'+vbat/10-(vbat/100)*10; line1[3] = '0'+vbat-(vbat/10)*10;
+  #endif
+  #ifdef POWERMETER
+    intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+    line2[5] = '0' + intPowerMeterSum / 10000;
+    line2[6] = '0' + intPowerMeterSum / 1000 - (intPowerMeterSum/10000) * 10;
+    line2[7] = '0' + intPowerMeterSum / 100  - (intPowerMeterSum/1000)  * 10;
+    line2[8] = '0' + intPowerMeterSum / 10   - (intPowerMeterSum/100)   * 10;
+    line2[9] = '0' + intPowerMeterSum        - (intPowerMeterSum/10)    * 10;
+    line2[13] = '0'+powerTrigger1/100; line2[14] = '0'+powerTrigger1/10-(powerTrigger1/100)*10; line2[15] = '0'+powerTrigger1-(powerTrigger1/10)*10;
+  #endif
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    LCDprint(0xFE);LCDprint('b');LCDprint(10);LCDprint(((vbat-VBATLEVEL1_3S)*100)/VBATREF); // bar graph
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+    break;
+  case 'C': // button C on Textstar LCD -> angles 
+    uint16_t unit;
+    strcpy(line1,"AngX  ___._ deg ");
+    /*            0123456789.12345*/
+    strcpy(line2,"AngY  ___._ deg ");
+    if (angle[0] < 0 ) {
+      unit = -angle[0];
+      line1[5] = '-';
+    } else 
+      unit = angle[0];
+    //line1[5] = '0' + unit / 10000;
+    line1[6] = '0' + unit / 1000; //- (unit/10000) * 10;
+    line1[7] = '0' + unit / 100  - (unit/1000)  * 10;
+    line1[8] = '0' + unit / 10   - (unit/100)   * 10;
+    line1[10] = '0' + unit       - (unit/10)    * 10;
+    if (angle[1] < 0 ) {
+      unit = -angle[1];
+      line2[5] = '-';
+    } else 
+      unit = angle[1];
+    //line2[5] = '0' + unit / 10000;
+    line2[6] = '0' + unit / 1000; //- (unit/10000) * 10;
+    line2[7] = '0' + unit / 100  - (unit/1000)  * 10;
+    line2[8] = '0' + unit / 10   - (unit/100)   * 10;
+    line2[10] = '0' + unit       - (unit/10)    * 10;
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+    break;      
+  case 'D': // button C on Textstar LCD 
+    strcpy(line1,"Button D        ");
+    /*            0123456789.12345*/
+    strcpy(line2,"         pressed");
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+    break; 
+  }
+#endif
   if (Serial.available()) {
     switch (Serial.read()) {
-    case 'A': //arduino to GUI all data
+    #ifdef LCD_TELEMETRY
+      case 'A': // button A press
+      if (telemetry=='A') telemetry = 0; else { telemetry = 'A'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'B': // button B press
+      if (telemetry=='B') telemetry = 0; else { telemetry = 'B'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'C': // button C press
+      if (telemetry=='C') telemetry = 0; else { telemetry = 'C'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'D': // button D press
+      if (telemetry=='D') telemetry = 0; else { telemetry = 'D'; LCDprint(12); /* clear screen */ }
+      break;
+      case 'a': // button A release
+      case 'b': // button B release
+      case 'c': // button C release
+      case 'd': // button D release
+      break;      
+    #endif
+      case 'M': // Multiwii @ arduino to GUI all data
       point=0;
-      serialize8('A');
+      serialize8('M');
       for(i=0;i<3;i++) serialize16(accSmooth[i]);
       for(i=0;i<3;i++) serialize16(gyroData[i]); //12
       serialize16(altitudeSmooth);
@@ -2225,7 +2457,18 @@
       serialize8(dynThrPID);
       serialize8(activateAcc8);serialize8(activateBaro8);serialize8(activateMag8);//80
       serialize8(activateCamStab8);serialize8(activateCamTrig8);//82
-      serialize8('A');
+
+      #if defined(POWERMETER)
+      intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+      intPowerTrigger1 = powerTrigger1 * PLEVELSCALE;
+      #else
+      intPowerMeterSum = 0;  
+      intPowerTrigger1 = 0;   
+      #endif    
+      serialize16(intPowerMeterSum);  
+      serialize16(intPowerTrigger1);
+      serialize8(vbat);
+      serialize8('M');
       Serial.write(s,point);
       break;
     case 'O':  // arduino to OSD data - contribution from MIS
@@ -2245,8 +2488,8 @@
       serialize8('O'); //49
       UartSendData();
       break;
-    case 'C': //GUI to arduino param
-      while (Serial.available()<21) {}
+    case 'E': //GUI write params to eeprom @ arduino
+      while (Serial.available()<23) {}
       for(i=0;i<3;i++) {P8[i]= Serial.read(); I8[i]= Serial.read(); D8[i]= Serial.read();}
       PLEVEL8 = Serial.read(); ILEVEL8 = Serial.read();
       rcRate8 = Serial.read(); rcExpo8 = Serial.read();
@@ -2254,9 +2497,10 @@
       dynThrPID = Serial.read();
       activateAcc8 = Serial.read();activateBaro8 = Serial.read();activateMag8 = Serial.read();
       activateCamStab8 = Serial.read();activateCamTrig8 = Serial.read();
+      powerTrigger1 = (Serial.read() + 256* Serial.read() ) / PLEVELSCALE; // we rely on writeParams() to compute corresponding pAlarm value
       writeParams();
       break;
-    case 'D': //GUI to arduino calibration request
+    case 'S': //GUI to arduino Sensor calibration reques
       calibratingA=400;
       break;
     }
