Only in .: .DS_Store
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/EEPROM.pde ./EEPROM.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/EEPROM.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./EEPROM.pde	2011-06-11 13:51:32.000000000 +0200
@@ -8,6 +8,11 @@
   for(i=0;i<3;i++) accZero[i] = (EEPROM.read(p++)&0xff) + (EEPROM.read(p++)<<8); // 28
   for(i=0;i<3;i++) magZero[i] = (EEPROM.read(p++)&0xff) + (EEPROM.read(p++)<<8); // 34
 
+ #if defined(POWERMETER)
+  powerTrigger1 = EEPROM.read(p++);
+  pAlarm = (uint32_t) powerTrigger1 * (uint32_t) PLEVELSCALE * (uint32_t) PLEVELDIV; // need to cast before multiplying
+ #endif
+
   for(i=0;i<7;i++) lookupRX[i] = (2500+rcExpo8*(i*i-25))*i*(int32_t)rcRate8/1250;
 }
 
@@ -18,6 +23,9 @@
   for(i=0;i<6;i++) EEPROM.write(p++,activate[i]); //22
   for(i=0;i<3;i++) {EEPROM.write(p++,accZero[i]);EEPROM.write(p++,accZero[i]>>8&0xff);} // 28
   for(i=0;i<3;i++) {EEPROM.write(p++,magZero[i]);EEPROM.write(p++,magZero[i]>>8&0xff);} // 34
+ #if defined(POWERMETER)
+  EEPROM.write(p++,powerTrigger1);
+ #endif
   readEEPROM();
   blinkLED(15,20,1);
 }
@@ -36,6 +44,9 @@
   yawRate = 0;
   dynThrPID = 0;
   for(uint8_t i=0;i<6;i++) activate[i] = 0;
+ #if defined(POWERMETER)
+  powerTrigger1 = 0;
+ #endif
   writeParams();
 }
-
+
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/IMU.pde ./IMU.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/IMU.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./IMU.pde	2011-06-11 13:51:32.000000000 +0200
@@ -235,4 +235,4 @@
     // Attitude of the cross product vector GxM
     heading = _atan2(EstG.V.Z * EstM.V.X - EstG.V.X * EstM.V.Z, EstG.V.Y * EstM.V.Z - EstG.V.Z * EstM.V.Y) / 10;
   #endif 
-}
+}
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/LCD.pde ./LCD.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/LCD.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./LCD.pde	2011-06-11 13:51:32.000000000 +0200
@@ -60,12 +60,29 @@
       strcpy(line1,"                ");
       i=0; char* point = param[p].paramText; while (*point) line1[i++] = *point++;
       uint16_t unit = *param[p].var;
+     #if defined(POWERMETER)
+      if (p > PARAMMOTORSTART && p < PARAMMOTOREND)
+        // pmeter values need special treatment, too many digits to fit standard 8 bit scheme
+        unit = pMeter[p-PARAMMOTOROFFSET] / PLEVELDIV; // [0:1000] * 1000/3 samples per second(loop time) * 60 seconds *5 minutes -> [0:10000 e4] per motor
+                                            // (that is full throttle for 5 minutes sampling with high sampling rate for wmp only)
+                                            // times 6 for a maximum of 6 motors equals [0:60000 e4] for the sum
+                                            // we are only interested in the big picture, so divide by 10.000
+     #endif
       if (p == 12) {unit *=2;} // RC RATE can go up to 500
       char c1 = '0'+unit/100; char c2 = '0'+unit/10-(unit/100)*10; char c3 = '0'+unit-(unit/10)*10;
       if (param[p].decimal == 0) {line2[6] = c1;  line2[7] = c2;   line2[8] = c3;}
       if (param[p].decimal == 1) {line2[5] = c1;  line2[6] = c2;   line2[7] = '.'; line2[8] = c3;}
       if (param[p].decimal == 2) {line2[5] = c1;  line2[6] = '.';  line2[7] = c2;  line2[8] = c3;}
       if (param[p].decimal == 3) {line2[4] = '0'; line2[5] = '.';  line2[6] = c1;  line2[7] = c2; line2[8] = c3;}
+      #if defined(POWERMETER) // so far, only used for POWERMETER functionality, but  it is general purpose
+      if (param[p].decimal == 16) { // not 16 digits but a 16 bit unsigned value; so need 5 digits base 10 to represent [0:65535]
+        line2[4] = '0' + unit / 10000;
+        line2[5] = '0' + unit / 1000 - (unit/10000) * 10;
+        line2[6] = '0' + unit / 100  - (unit/1000)  * 10;
+        line2[7] = '0' + unit / 10   - (unit/100)   * 10;
+        line2[8] = '0' + unit        - (unit/10)    * 10;
+      }
+      #endif
 
       #if defined(LCD_TEXTSTAR)
         LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
@@ -78,13 +95,14 @@
     }
     for (chan = ROLL; chan < 4; chan++) rcData[chan] = readRawRC(chan);
     //switch config param with pitch
-    if (rcData[PITCH] < MINCHECK && paramActive == 0 && p<21) {
+    if (rcData[PITCH] < MINCHECK && paramActive == 0 && p<= PARAMMAX) {
       paramActive = 1;refreshLCD=1;blinkLED(10,20,1);
       p++;
+      if (p>PARAMMAX) p=0;
     }
-    if (rcData[PITCH] > MAXCHECK && paramActive == 0 && p>0) {
+    if (rcData[PITCH] > MAXCHECK && paramActive == 0 && p>=0) {
       paramActive = 1;refreshLCD=1;blinkLED(10,20,1);
-      p--; 
+      if (p==0) p=PARAMMAX; else p--;
     }
     if (rcData[PITCH] < MAXCHECK && rcData[PITCH] > MINCHECK)  paramActive = 0;
     //+ or - param with low and high roll
@@ -113,4 +131,7 @@
   #else
     Serial.begin(SERIAL_COM_SPEED);
   #endif
-}
+  #ifdef LCD_TELEMETRY
+    delay(1000); // keep exit message visible for one second even if (auto)telemetry continues writing in main loop
+  #endif
+}
Only in /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607: MultiWii_dev20110607.pde
Only in .: MultiWii_dev20110607_plus.diff
Only in .: MultiWii_dev20110607_plus_TRI40.pde
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/Output.pde ./Output.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/Output.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./Output.pde	2011-06-11 13:51:32.000000000 +0200
@@ -59,6 +59,25 @@
   writeMotors();
 }
 
+#if defined(POWERMETER)
+void logMotorsPower() {
+  uint32_t amp;
+  /* true cubic function; when divided by vbat_max=126 (12.6V) for 3 cell battery this gives maximum value of ~ 1000 */
+  const uint32_t amperes[16] =   {31, 246, 831, 1969, 3845, 6645, 10551, 15750, 22425, 30762, 40944, 53156, 67583, 84410, 103821, 126000 };
+
+  if (vbat) { // by all means - must avoid division by zero 
+    for (uint8_t i =0;i<NUMBER_MOTOR;i++) {
+
+      amp = amperes[(motor[i] - 1000)>>6] / vbat; // range mapped from [1000:2000] => [0:1000]; then break that up into 16 ranges; lookup amp
+     #ifdef LOG_VALUES
+      pMeter[i]+= amp; // sum up over time the mapped ESC input 
+     #endif
+      pMeter[6]+= amp; // total sum over all motors
+    }
+  }
+}
+#endif
+
 void initOutput() {
   for(uint8_t i=0;i<NUMBER_MOTOR;i++)
     pinMode(PWM_PIN[i],OUTPUT);
@@ -219,9 +238,10 @@
     servo[1]  = constrain(1500 + YAW_DIRECTION * (axisPID[YAW] - axisPID[PITCH]), 1020, 2000); //RIGHT
   #endif
   #ifdef TRI
-    motor[0] = rcCommand[THROTTLE] + axisPID[PITCH]*4/3 ;                 //REAR
-    motor[1] = rcCommand[THROTTLE] - axisPID[ROLL] - axisPID[PITCH]*2/3 ; //RIGHT
-    motor[2] = rcCommand[THROTTLE] + axisPID[ROLL] - axisPID[PITCH]*2/3 ; //LEFT
+  /* respect geoemtric layout of TRI for thrust distribution */
+    motor[0] = rcCommand[THROTTLE] + axisPID[PITCH]*4/6 ;                 //REAR
+    motor[1] = rcCommand[THROTTLE] - axisPID[ROLL]/2 - axisPID[PITCH]/6 ; //RIGHT
+    motor[2] = rcCommand[THROTTLE] + axisPID[ROLL]/2 - axisPID[PITCH]/6 ; //LEFT
     servo[0] = constrain(TRI_YAW_MIDDLE + YAW_DIRECTION * axisPID[YAW], TRI_YAW_CONSTRAINT_MIN, TRI_YAW_CONSTRAINT_MAX); //REAR
   #endif
   #ifdef QUADP
@@ -332,4 +352,4 @@
       motor[i] = MINCOMMAND;
   }
 }
-
+
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/RX.pde ./RX.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/RX.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./RX.pde	2011-06-11 13:51:32.000000000 +0200
@@ -157,4 +157,4 @@
     if ( rcDataMean[chan] > rcData[chan] +3)  rcData[chan] = rcDataMean[chan]-2;
   }
 }
-
+
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/Sensors.pde ./Sensors.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/Sensors.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./Sensors.pde	2011-06-11 13:51:32.000000000 +0200
@@ -10,7 +10,9 @@
 /*** I2C address ***/
 
 //#define ADXL345_ADDRESS 0x3A
-#define ADXL345_ADDRESS 0xA6   //Alternative adress for use with PipoISU WARNING: Conflicts with a Wii Motion plus!
+#ifndef ADXL345_ADDRESS
+ #define ADXL345_ADDRESS 0xA6   //Alternative adress for use with PipoISU WARNING: Conflicts with a Wii Motion plus!
+#endif
 
 #define BMA180_ADDRESS 0x80    // match FFIMU choice
 //#define BMA180_ADDRESS 0x82
@@ -670,4 +672,4 @@
   if (BARO) Baro_init();
   if (ACC) ACC_init();
   if (MAG) Mag_init();
-}
+}
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/Serial.pde ./Serial.pde
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/Serial.pde	2011-06-07 23:53:22.000000000 +0200
+++ ./Serial.pde	2011-06-11 13:51:32.000000000 +0200
@@ -24,11 +24,141 @@
 void serialCom() {
   int16_t a;
   uint8_t i;
-  if (Serial.available()) {
+  uint16_t intPowerMeterSum, intPowerTrigger1;   
+#ifdef LCD_TELEMETRY
+  // LCD_BAR(n,v) : draw a bar graph - n number of chars for width, v value in % to display
+  #ifdef LCD_TEXTSTAR
+    #define LCD_BAR(n,v) { LCDprint(0xFE);LCDprint('b');LCDprint(n);LCDprint(v); }
+  #else 
+    #define LCD_BAR(n,v) {} // add your own implementation here
+  #endif
+  char line1[17],line2[17];
+  static uint8_t telecycle = 0;
+  
+  if (++telecycle > TELEMETRY_CYCLES) {
+     telecycle = 0;
+
+     switch (telemetry) { // output telemetry data, if one of four modes is set
+     case 'C': // button C on Textstar LCD -> cycle time
+       strcpy(line1,"Cycle    _____us"); //uin16_t cycleTime
+       /*            0123456789.12345*/
+       strcpy(line2,"[_____, _____]us"); //uin16_t cycleTimeMax
+       line1[9] = '0' + cycleTime / 10000;
+       line1[10] = '0' + cycleTime / 1000 - (cycleTime/10000) * 10;
+       line1[11] = '0' + cycleTime / 100  - (cycleTime/1000)  * 10;
+       line1[12] = '0' + cycleTime / 10   - (cycleTime/100)   * 10;
+       line1[13] = '0' + cycleTime        - (cycleTime/10)    * 10;
+     #ifdef LOG_VALUES
+       line2[1] = '0' + cycleTimeMin / 10000;
+       line2[2] = '0' + cycleTimeMin / 1000 - (cycleTimeMin/10000) * 10;
+       line2[3] = '0' + cycleTimeMin / 100  - (cycleTimeMin/1000)  * 10;
+       line2[4] = '0' + cycleTimeMin / 10   - (cycleTimeMin/100)   * 10;
+       line2[5] = '0' + cycleTimeMin        - (cycleTimeMin/10)    * 10;
+       line2[8] = '0' + cycleTimeMax / 10000;
+       line2[9] = '0' + cycleTimeMax / 1000 - (cycleTimeMax/10000) * 10;
+       line2[10] = '0' + cycleTimeMax / 100  - (cycleTimeMax/1000)  * 10;
+       line2[11] = '0' + cycleTimeMax / 10   - (cycleTimeMax/100)   * 10;
+       line2[12] = '0' + cycleTimeMax        - (cycleTimeMax/10)    * 10;
+       LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+     #endif
+       LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+       break;
+     case 'B': // button B on Textstar LCD -> Voltage, PowerSum and power alarm trigger value
+       strcpy(line1,"__._V   _____mAh"); //uint8_t vbat, intPowerMeterSum
+       /*            0123456789.12345*/
+       //strcpy(line2,".......  ......."); // intPowerMeterSum, intPowerTrigger1
+     #ifdef VBAT
+       line1[0] = '0'+vbat/100; line1[1] = '0'+vbat/10-(vbat/100)*10; line1[3] = '0'+vbat-(vbat/10)*10;
+     #endif
+     #ifdef POWERMETER
+       intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+       line1[8] = '0' + intPowerMeterSum / 10000;
+       line1[9] = '0' + intPowerMeterSum / 1000 - (intPowerMeterSum/10000) * 10;
+       line1[10] = '0' + intPowerMeterSum / 100  - (intPowerMeterSum/1000)  * 10;
+       line1[11] = '0' + intPowerMeterSum / 10   - (intPowerMeterSum/100)   * 10;
+       line1[12] = '0' + intPowerMeterSum        - (intPowerMeterSum/10)    * 10;
+       //line2[13] = '0'+powerTrigger1/100; line2[14] = '0'+powerTrigger1/10-(powerTrigger1/100)*10; line2[15] = '0'+powerTrigger1-(powerTrigger1/10)*10;
+     #endif
+       LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+       LCDprint(0xFE);LCDprint('L');LCDprint(2); //position on line 2 of LCD
+     #ifdef VBAT
+       LCD_BAR(7, (((vbat-VBATLEVEL1_3S)*100)/VBATREF) );
+       LCDprintChar("  ");
+     #endif
+     #ifdef POWERMETER  
+       //     intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+       //   pAlarm = (uint32_t) powerTrigger1 * (uint32_t) PLEVELSCALE * (uint32_t) PLEVELDIV; // need to cast before multiplying
+       if (powerTrigger1)
+          LCD_BAR(7, (intPowerMeterSum/powerTrigger1 *2) ); // bar graph powermeter (scale intPowerMeterSum/powerTrigger1 with *100/PLEVELSCALE)
+     #endif
+       break;
+      case 'A': // button A on Textstar LCD -> angles 
+       uint16_t unit;
+       strcpy(line1,"DegX  ___._ ");
+       /*            0123456789.12345*/
+       strcpy(line2,"DegY  ___._ ");
+       if (angle[0] < 0 ) {
+         unit = -angle[0];
+         line1[5] = '-';
+       } else 
+         unit = angle[0];
+       //line1[5] = '0' + unit / 10000;
+       line1[6] = '0' + unit / 1000; //- (unit/10000) * 10;
+       line1[7] = '0' + unit / 100  - (unit/1000)  * 10;
+       line1[8] = '0' + unit / 10   - (unit/100)   * 10;
+       line1[10] = '0' + unit       - (unit/10)    * 10;
+       if (angle[1] < 0 ) {
+         unit = -angle[1];
+         line2[5] = '-';
+       } else 
+         unit = angle[1];
+       //line2[5] = '0' + unit / 10000;
+       line2[6] = '0' + unit / 1000; //- (unit/10000) * 10;
+       line2[7] = '0' + unit / 100  - (unit/1000)  * 10;
+       line2[8] = '0' + unit / 10   - (unit/100)   * 10;
+       line2[10] = '0' + unit       - (unit/10)    * 10;
+       LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+       LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+       break;      
+     case 'D': // button D on Textstar LCD -> sensors
+     #define GYROLIMIT 30 // threshold: for larger values replace bar with dots
+     #define ACCLIMIT 40 // threshold: for larger values replace bar with dots
+       LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar("G "); //refresh line 1 of LCD
+       if (abs(gyroData[0]) < GYROLIMIT) { LCD_BAR(4,(abs(gyroData[0])*100/GYROLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+       if (abs(gyroData[1]) < GYROLIMIT) { LCD_BAR(4,(abs(gyroData[1])*100/GYROLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+       if (abs(gyroData[2]) < GYROLIMIT) { LCD_BAR(4,(abs(gyroData[2])*100/GYROLIMIT)) } else LCDprintChar("....");
+       LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar("A "); //refresh line 2 of LCD
+       if (abs(accSmooth[0]) < ACCLIMIT) { LCD_BAR(4,(abs(accSmooth[0])*100/ACCLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+       if (abs(accSmooth[1]) < ACCLIMIT) { LCD_BAR(4,(abs(accSmooth[1])*100/ACCLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+       if (abs(accSmooth[2] - acc_1G) < ACCLIMIT) { LCD_BAR(4,(abs(accSmooth[2]-acc_1G)*100/ACCLIMIT)) } else LCDprintChar("....");
+       break; 
+   } // end switch (telemetry) 
+} // end if (++telecycle > TELEMETRY_CYCLES)
+#endif //  LCD_TELEMETRY
+if (Serial.available()) {
     switch (Serial.read()) {
-    case 'A': //arduino to GUI all data
+    #ifdef LCD_TELEMETRY
+      case 'A': // button A press
+      if (telemetry=='A') telemetry = 0; else { telemetry = 'A'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'B': // button B press
+      if (telemetry=='B') telemetry = 0; else { telemetry = 'B'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'C': // button C press
+      if (telemetry=='C') telemetry = 0; else { telemetry = 'C'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'D': // button D press
+      if (telemetry=='D') telemetry = 0; else { telemetry = 'D'; LCDprint(12); /* clear screen */ }
+      break;
+      case 'a': // button A release
+      case 'b': // button B release
+      case 'c': // button C release
+      case 'd': // button D release
+      break;      
+    #endif
+      case 'M': // Multiwii @ arduino to GUI all data
       point=0;
-      serialize8('A');
+      serialize8('M');
       serialize8(VERSION);  // MultiWii Firmware version
       for(i=0;i<3;i++) serialize16(accSmooth[i]);
       for(i=0;i<3;i++) serialize16(gyroData[i]/8); //13
@@ -76,8 +206,19 @@
       serialize8(rollPitchRate); serialize8(yawRate);
       serialize8(dynThrPID);
       for(i=0;i<6;i++) serialize8(activate[i]);
-      serialize8('A');
-      UartSendData(); // Serial.write(s,point);
+      #if defined(POWERMETER)
+      intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+      intPowerTrigger1 = powerTrigger1 * PLEVELSCALE;
+      #else
+      intPowerMeterSum = 0;  
+      intPowerTrigger1 = 0;   
+      #endif    
+      serialize16(intPowerMeterSum);  
+      serialize16(intPowerTrigger1);
+      serialize8(vbat);
+      serialize8('M');
+      Serial.write(s,point); // must use old style parameter sending
+//      UartSendData(); // does not work for me - leads to spurious extra data in arduino's serial input chain!
       break;
     case 'O':  // arduino to OSD data - contribution from MIS
       point=0;
@@ -96,8 +237,8 @@
       serialize8('O'); //49
       UartSendData();
       break;
-    case 'C': //GUI to arduino param
-      while (Serial.available()<27) {}
+    case 'W': //GUI write params to eeprom @ arduino
+      while (Serial.available()<29) {}
       for(i=0;i<4;i++) {P8[i]= Serial.read(); I8[i]= Serial.read(); D8[i]= Serial.read();} //9
       P8[PIDLEVEL] = Serial.read(); I8[PIDLEVEL] = Serial.read(); //11
       P8[PIDMAG] = Serial.read();
@@ -105,9 +246,15 @@
       rollPitchRate = Serial.read(); yawRate = Serial.read(); //16
       dynThrPID = Serial.read();
       for(i=0;i<6;i++) activate[i] = Serial.read(); //22
+     #if defined(POWERMETER)
+      powerTrigger1 = (Serial.read() + 256* Serial.read() ) / PLEVELSCALE; // we rely on writeParams() to compute corresponding pAlarm value
+     #else
+      Serial.read();
+      Serial.read(); // so we unload the two bytes
+     #endif
       writeParams();
       break;
-    case 'D': //GUI to arduino ACC calibration request
+    case 'S': //GUI to arduino ACC calibration request
       calibratingA=400;
       break;
     case 'E': //GUI to arduino MAG calibration request
@@ -115,4 +262,4 @@
       break;
     }
   }
-}
+}
Only in .: TRI40.h
diff -u /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/config.h ./config.h
--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/config.h	2011-06-07 23:53:22.000000000 +0200
+++ ./config.h	2011-06-11 13:54:55.000000000 +0200
@@ -84,6 +84,10 @@
 /* ADC accelerometer */ // for 5DOF from sparkfun, uses analog PIN A1/A2/A3
 //#define ADCACC
 
+/* FReeIMU shortcut , currently used for adxl345 address */
+//#define FREEIMU 01
+
+
 /* The following lines apply only for specific receiver with only one PPM sum signal, on digital PIN 2
    IF YOUR RECEIVER IS NOT CONCERNED, DON'T UNCOMMENT ANYTHING. Note this is mandatory for a Y6 setup on a promini
    Select the right line depending on your radio brand. Feel free to modify the order in your PPM order is different */
@@ -154,8 +158,57 @@
 #define TRI_YAW_CONSTRAINT_MAX 2000
 #define TRI_YAW_MIDDLE 1500
 
-//****** end of advanced users settings *************
+/* enable monitoring of the power consumption from battery (think of mAh) */
+/* allows to set alarm value in GUI or via LCD */
+/* Current first implementation method is pure software. */
+/* soft: - (good results +-5% for plush and mystery ESCs @ 2S and 3S, not good with SuperSimple ESC */
+/*      00. relies on your combo of battery type (Voltage, cpacity), ESC, ESC settings, motors, props */
+/*      0. output is a value that linearily scales to power (mAh) */
+/*      1. get voltage reading right first */
+/*      2. start with freshly charged battery */
+/*      3. go fly your typical flight (routine and duration) */
+/*      4. at end connect to GUI or LCD and read the power value; write it down (example 4711)*/
+/*      5. charge battery, write down amount of energy needed (example 722 mAh) */
+/*      6. compute alarm value for desired power threshold (example 750 mAh : alarm = 4711 / 722 * 750) */
+/*      7. set alarm value in GUI or LCD */
+/*      8. enjoy your new battery alarm - possibly repeat steps 2 .. 7 */
+/*      9. if you want the numbers to represent your mAh value, you must change PLEVELDIV */
+//#define POWERMETER soft
+/* the sum of all powermeters ranges from [0:60000 e4] theoretically. */
+/* the alarm level from eeprom is out of [0:255], so we multipy alarm level with PLEVELSCALE and with 1e4 before comparing */
+#define PLEVELSCALE 50 // if you change this value for other granularity, you must search for comments in code to change accordingly 
+/* larger PLEVELDIV will get you smaller value for power (mAh equivalent) */
+#define PLEVELDIV 10000 // if you lower PLEVELDIV, beware of overrun in uint32 pMeter
+
+/* to monitor system values (battery level, loop time etc. with LCD enable this */
+/* note: for now you must send single characters 'A', 'B', 'C', 'D' to request 4 different pages */
+/* New: the info page on the LCD does get updated automatically - for stop press same button again */
+/* easy to use with Textstar LCD - the 4 buttons are preconfigured to send 'A', 'B', 'C', 'D' */
+//#define LCD_TELEMETRY
+// update interval for telemtry data - every n cycles
+#define TELEMETRY_CYCLES 10
+/* to enable automatic hopping between 4 telemetry pages uncomment this. */
+/* This may be useful if your LCD has no buttons or the sending is broken */
+/* hopping is activated and deactivated in unarmed mode with throttle=low & roll=left & pitch=forward */
+/* The value represents the hopping interval in cpu time (micro seconds) */
+//#define LCD_TELEMETRY_AUTO 2000000
+/* on telemetry page B it gives a bar graph which shows how much voltage battery has left. Range from 0 to 12 Volt is not very informative */
+/* so we try do define a meaningful part. For a 3S battery we define full=12,6V and calculate how much it is above first warning level */
+/* Example: 12.6V - VBATLEVEL1_3S  (for me = 126 - 102 = 24) */
+#define VBATREF 24 
+
+/* to log values like max loop time and others to come, we need extra variables */
+/* if you do not want the additional computing time or are short on memory, then comment the following */
+#define LOG_VALUES
 
+//****** end of advanced users settings *************
+#ifndef ADXL345_ADDRESS
+    #ifdef FREEIMU
+      #define ADXL345_ADDRESS 0xA6 // taken from fabio's library and his post http://wbb.multiwii.com/viewtopic.php?f=8&t=262
+    #else
+      #define ADXL345_ADDRESS 0x3A
+    #endif
+#endif
 /**************************************/
 /****END OF CONFIGURABLE PARAMETERS****/
-/**************************************/
+/**************************************/
