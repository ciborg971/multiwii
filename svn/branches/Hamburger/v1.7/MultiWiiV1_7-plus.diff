--- MultiWiiV1_7.pde	2011-04-12 23:38:56.000000000 +0200
+++ MultiWiiV1_7_plus_TRI60.pde	2011-05-04 17:34:25.000000000 +0200
@@ -1,4 +1,12 @@
 /*
++++++++++++++++++++
++ LCD abort
++ LCD_TELEMETRY (and redefine for GUI)
++ POWERMETER
++ FreeIMU adaption with configurable address
+*/
+
+/*
 MultiWiiCopter by Alexandre Dubus
 www.multiwii.com
 April  2011     V1.7
@@ -91,6 +99,9 @@
 /* ADC accelerometer */ // for 5DOF from sparkfun, uses analog PIN A1/A2/A3
 //#define ADCACC
 
+/* FReeIMU shortcut , currently used for adxl345 address */
+//#define FREEIMU 01
+
 /* The following lines apply only for specific receiver with only one PPM sum signal, on digital PIN 2
    IF YOUR RECEIVER IS NOT CONCERNED, DON'T UNCOMMENT ANYTHING. Note this is mandatory for a Y6 setup
    Select the right line depending on your radio brand. Feel free to modify the order in your PPM order is different */
@@ -158,6 +169,37 @@
 #define TRI_YAW_CONSTRAINT_MAX 2000
 #define TRI_YAW_MIDDLE 1500
 
+/* to sum the power consumption from battery it is possible to sum up the signals sent to each ESC separately. */
+/* Under the asumption that a) the function from ESC signal to consumed power  quite follows a universal characteristic function */
+/* and b) the time base i.e. main loop time is quite stable and known */
+/* it will be possible to derive a value that corresponds to total consumed power */
+// see here for short howto: http://wbb.multiwii.com/viewtopic.php?f=8&t=167&start=30#p1421
+// epsecially if you are interested in conversion in mAh.
+//#define POWERMETER
+// the sum of all powermeters ranges from [0:60000 e4] theoretically.
+// the alarm level from eeprom is out of [0:255], so we multipy alarm level with PLEVELSCALE and with 1e4 before comparing
+#define PLEVELSCALE 100 
+#define PLEVELDIV 10000
+
+/* to monitor system values (battery level, loop time etc. with LCD enable this */
+/* note: for now you must send single characters 'A', 'B', 'C', 'D' to request 4 different screens */
+/* New: the info screen on the LCD does get updated automatically - for stop press same button again */
+/* easy to use with Textstar LCD - the 4 buttons are preconfigured to send 'A', 'B', 'C', 'D' */
+//#define LCD_TELEMETRY
+/* to enable automatic hopping between 4 telemetry changes uncomment this. */
+/* This may be useful if your LCD has no buttons or the sending is broken */
+/* hopping is activated and deactivated in unarmed mode with throttle=low & roll=left & pitch=forward */
+/* The value represents the hopping interval */
+//#define LCD_TELEMETRY_AUTO 2000000
+/* on page B it gives a bar graph which shows how much voltage battery has left. Range from 0 to 12 Volt is not very informative */
+/* so we try do define a meaningful part. For a 3S battery we define full=12,6V and calculate how much it is above first warning level */
+/* Example: 12.6V - VBATLEVEL1_3S  (for me = 126 - 102 = 24) */
+#define VBATREF 24 
+
+/* to log values like max loop time and others to come, we need extra variables */
+/* if you do not want the additional computing time or are short on memory, then comment the following */
+#define LOG_VALUES
+
 //****** end of advanced users settings *************
 
 /**************************************/
@@ -171,6 +213,12 @@
 #define V_BATPIN 3    // Analog PIN 3
 #define STABLEPIN     // will be defined for MEGA in a future version
 
+#include "/Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/meineCombi-7-v1-7/TRI60.h"
+
+#if defined(INTERNAL_I2C_PULLUPS) && ( FREEIMU == 01 )
+	#error "for freeimu v0.1 from fax8, you MUST undefine internal i2c pullups. Else you destroy board!"
+#endif
+
 #if defined(PROMINI)
   #define LEDPIN_PINMODE             pinMode (13, OUTPUT);
   #define LEDPIN_SWITCH              PINB |= 1<<5;     //switch LEDPIN state (digital PIN 13)
@@ -295,6 +343,10 @@
 static uint32_t rcTime;
 static uint32_t currentTime;
 static uint16_t cycleTime;          // this is the number in micro second to achieve a full loop, it can differ a little and is taken into account in the PID loop
+#ifdef LOG_VALUES
+static uint16_t cycleTimeMax = 0;          // highest ever cycle timen 
+static uint16_t cycleTimeMin = 65535;          // lowest ever cycle timen 
+#endif
 static uint16_t meanTime = 2000;    // this is the average time of the loop: around 2ms for a WMP config and 6ms for a NK+WMP config
 static uint16_t calibratingA;       // the calibration is done is the main loop. Calibrating decreases at each cycle down to 0, then we enter in a normal mode.
 static uint16_t calibratingG;
@@ -316,6 +368,30 @@
 static int16_t altitudeSmooth = 0;
 static uint8_t calibratedACC = 0;
 static uint8_t vbat;               //battery voltage in 0.1V steps
+#if defined(POWERMETER)
+#ifndef VBAT
+	#error "to use powermeter, you must also define and configure VBAT"
+#endif
+static uint32_t pMeter[7]; //we use [0:5] for six motors,[6] for sum
+static uint8_t pMeterV; // dummy to satisfy the paramStruct logic in ConfigurationLoop()
+static uint32_t pAlarm; // we scale the eeprom value from [0:255] to this value we can directly compare to the sum in pMeter[6]
+#define PARAMMAX 25
+#define PARAMMOTORSTART  16
+#define PARAMMOTOREND    24
+#define PARAMMOTOROFFSET 17
+#else
+#define PARAMMAX 16
+#endif
+
+#ifdef LCD_TELEMETRY
+static uint8_t telemetry = 0;
+#endif
+#ifdef LCD_TELEMETRY_AUTO
+  #ifndef LCD_TELEMETRY
+     #error "to use automatic telemetry, you must also define and configure LCD_TELEMETRY"
+  #endif
+static uint8_t telemetry_auto = 0;
+#endif
 
 // *********************
 // I2C general functions
@@ -568,17 +644,26 @@
 //  3) bit  b00000100 must be set on register 0x2D to read data (only once at the initialization)
 //  4) bits b00001011 must be set on register 0x31 to select the data format (only once at the initialization)
 #if defined(ADXL345)
+ #ifndef ADDR_ADXL345
+    #ifdef FREEIMU
+      #define ADDR_ADXL345 0xA6 // 0x10 //0x53 // taken from fabio's library and his post http://wbb.multiwii.com/viewtopic.php?f=8&t=262
+    #else
+      #define ADDR_ADXL345 0x3A
+    #endif
+ #endif
+
+
 static uint8_t rawADC_ADXL345[6];
 
 void i2c_ACC_init () {
   delay(10);
-  i2c_rep_start(0x3A+0);      // I2C write direction
+  i2c_rep_start(ADDR_ADXL345+0);      // I2C write direction
   i2c_write(0x2D);            // register 2D Power CTRL
   i2c_write(1<<3);            // Set measure bit 3 on
-  i2c_rep_start(0x3A+0);      // I2C write direction 
+  i2c_rep_start(ADDR_ADXL345+0);      // I2C write direction 
   i2c_write(0x31);            // DATA_FORMAT register
   i2c_write(0x0B);            // Set bits 3(full range) and 1 0 on (+/- 16g-range)
-  i2c_rep_start(0x3A+0);      // I2C write direction 
+  i2c_rep_start(ADDR_ADXL345+0);      // I2C write direction 
   i2c_write(0x2C);            // BW_RATE
   i2c_write(8+2+1);           // 200Hz sampling (see table 5 of the spec)
 
@@ -589,9 +674,9 @@
 
 void i2c_ACC_getADC () {
   TWBR = ((16000000L / 400000L) - 16) / 2; // change the I2C clock rate to 400kHz, ADXL435 is ok with this speed
-  i2c_rep_start(0x3A);     // I2C write direction
+  i2c_rep_start(ADDR_ADXL345);     // I2C write direction
   i2c_write(0x32);         // Start multiple read at reg 0x32 ADX
-  i2c_rep_start(0x3A +1);  // I2C read direction => 1
+  i2c_rep_start(ADDR_ADXL345 +1);  // I2C read direction => 1
   for(uint8_t i = 0; i < 5; i++) {
     rawADC_ADXL345[i]=i2c_readAck();}
   rawADC_ADXL345[5]= i2c_readNak();
@@ -1531,6 +1616,9 @@
 static uint8_t checkNewConf = 134;
 static uint8_t activateAcc8,activateBaro8,activateMag8;
 static uint8_t activateCamStab8,activateCamTrig8;
+#if defined(POWERMETER)
+static uint8_t powerTrigger1=0; // trigger for alarm based on power consumption
+#endif
 
 void readEEPROM() {
   uint8_t i,p=1;
@@ -1543,6 +1631,10 @@
   activateAcc8 = EEPROM.read(p++);activateBaro8 = EEPROM.read(p++);activateMag8 = EEPROM.read(p++);
   activateCamStab8 = EEPROM.read(p++);activateCamTrig8 = EEPROM.read(p++);
   for(i=0;i<3;i++) accZero[i] = (EEPROM.read(p++)&0xff) + (EEPROM.read(p++)<<8);
+  #if defined(POWERMETER)
+  powerTrigger1 = EEPROM.read(p++);
+  pAlarm = (uint32_t) powerTrigger1 * (uint32_t) PLEVELSCALE * (uint32_t) PLEVELDIV; // need to cast before multiplying
+  #endif
   //note on the following lines: we do this calcul here because it's a static and redundant result and we don't want to load the critical loop whith it
   rcFactor1 = rcRate8/50.0*rcExpo8/100.0/250000.0;
   rcFactor2 = (100-rcExpo8)*rcRate8/5000.0;
@@ -1560,6 +1652,9 @@
   EEPROM.write(p++,activateAcc8);EEPROM.write(p++,activateBaro8);EEPROM.write(p++,activateMag8);
   EEPROM.write(p++,activateCamStab8);EEPROM.write(p++,activateCamTrig8);
   for(i=0;i<3;i++) {EEPROM.write(p++,accZero[i]);EEPROM.write(p++,accZero[i]>>8&0xff);}
+  #if defined(POWERMETER)
+  EEPROM.write(p++,powerTrigger1);
+  #endif
   readEEPROM();
   blinkLED(15,20,1);
 }
@@ -1577,6 +1672,9 @@
     dynThrPID = 0;
     activateAcc8 = 0;activateBaro8 = 0;activateMag8 = 0;
     activateCamStab8 = 0;activateCamTrig8 = 0;
+  #if defined(POWERMETER)
+    powerTrigger1 = 0;
+  #endif
     writeParams();
   }
 }
@@ -1615,9 +1713,9 @@
     // Modified by Luca Brizzi aka gtrick90 @ RCG
     LCDprint(0xFE);LCDprint(0x43);LCDprint(0x02); //cursor blink mode
     LCDprint(0x0c); //clear screen
-    LCDprintChar("MultiWii");
+    LCDprintChar("MultiWii Config");
     LCDprint(0x0d); // carriage return
-    LCDprintChar("CONFIG PARAMS");
+    LCDprintChar("for all params");
     delay(2500);
     LCDprint(0x0c); //clear screen
   #else
@@ -1627,6 +1725,8 @@
   #endif
 }
 
+
+
 void configurationLoop() {
   uint8_t chan,i;
   uint8_t param,paramActive;
@@ -1651,6 +1751,17 @@
   {"RC RATE", &rcRate8,2,2},       {"RC EXPO", &rcExpo8,2,2},
   {"PITCH&ROLL RATE", &rollPitchRate,2,2}, {"YAW RATE", &yawRate,2,2},
   {"THROTTLE PID", &dynThrPID,2,2},
+#if defined(POWERMETER)
+  {"pMeter Motor 0", &pMeterV,16,0}, //17
+  {"pMeter Motor 1", &pMeterV,16,0}, //18
+  {"pMeter Motor 2", &pMeterV,16,0}, //19
+  {"pMeter Motor 3", &pMeterV,16,0}, //20  
+  {"pMeter Motor 4", &pMeterV,16,0}, //21
+  {"pMeter Motor 5", &pMeterV,16,0}, //22
+  {"pMeter Sum", &pMeterV,16,0}, //23
+  {"pAlarm /100", &powerTrigger1,0,1}, //24
+  {"Battery Volt", &vbat,1,0}, //25
+#endif
   };
 
   initLCD();
@@ -1661,13 +1772,29 @@
       strcpy(line1,"                ");
       i=0; char* point = p[param].paramText; while (*point) line1[i++] = *point++;
       uint16_t unit = *p[param].var;
+      #if defined(POWERMETER)
+      if (param > PARAMMOTORSTART && param < PARAMMOTOREND)
+        // pmeter values need special treatment, too many digits to fit standard 8 bit scheme
+        unit = pMeter[param-PARAMMOTOROFFSET] / PLEVELDIV; // [0:1000] * 1000/3 samples per second(loop time) * 60 seconds *5 minutes -> [0:10000 e4] per motor
+                                            // (that is full throttle for 5 minutes sampling with high sampling rate for wmp only)
+                                            // times 6 for a maximum of 6 motors equals [0:60000 e4] for the sum
+                                            // we are only interested in the big picture, so drop 4 lower digits base 10
+      #endif
       if (param == 12) {unit *=2;} // RC RATE can go up to 500
       char c1 = '0'+unit/100; char c2 = '0'+unit/10-(unit/100)*10; char c3 = '0'+unit-(unit/10)*10;
       if (p[param].decimal == 0) {line2[6] = c1;  line2[7] = c2;   line2[8] = c3;}
       if (p[param].decimal == 1) {line2[5] = c1;  line2[6] = c2;   line2[7] = '.'; line2[8] = c3;}
       if (p[param].decimal == 2) {line2[5] = c1;  line2[6] = '.';  line2[7] = c2;  line2[8] = c3;}
       if (p[param].decimal == 3) {line2[4] = '0'; line2[5] = '.';  line2[6] = c1;  line2[7] = c2; line2[8] = c3;}
-
+      #if defined(POWERMETER) // so far, only used for POWERMETER functionality, but otherwise it is general purpose
+      if (p[param].decimal == 16) { // not 16 digits but a 16 bit unsigned value; so need 5 digits base 10 to represent [0:65535]
+        line2[4] = '0' + unit / 10000;
+        line2[5] = '0' + unit / 1000 - (unit/10000) * 10;
+        line2[6] = '0' + unit / 100  - (unit/1000)  * 10;
+        line2[7] = '0' + unit / 10   - (unit/100)   * 10;
+        line2[8] = '0' + unit        - (unit/10)    * 10;
+      }
+      #endif
       #if defined(LCD_TEXTSTAR)
         LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
         LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
@@ -1679,13 +1806,14 @@
     }
     for (chan = ROLL; chan < 4; chan++) rcData[chan] = readRawRC(chan);
     //switch config param with pitch
-    if (rcData[PITCH] < MINCHECK && paramActive == 0 && param<16) {
+    if (rcData[PITCH] < MINCHECK && paramActive == 0 && param<= PARAMMAX) {
       paramActive = 1;refreshLCD=1;blinkLED(10,20,1);
       param++;
+      if (param>PARAMMAX) param=0;
     }
-    if (rcData[PITCH] > MAXCHECK && paramActive == 0 && param>0) {
+    if (rcData[PITCH] > MAXCHECK && paramActive == 0 && param>=0) {
       paramActive = 1;refreshLCD=1;blinkLED(10,20,1);
-      param--; 
+      if (param==0) param=PARAMMAX; else param--;
     }
     if (rcData[PITCH] < MAXCHECK && rcData[PITCH] > MINCHECK)  paramActive = 0;
     //+ or - param with low and high roll
@@ -1700,16 +1828,18 @@
       if (param == 0) *p[4].var = *p[0].var; //PITCH P
     }
     if (rcData[ROLL] < MAXCHECK && rcData[ROLL]  > MINCHECK) valActive = 0;
-    if (rcData[YAW]  < MINCHECK && rcData[PITCH] > MAXCHECK) LCD = 0;
+    if (rcData[YAW]  < MINCHECK && rcData[PITCH] > MAXCHECK) LCD = 0; // save and exit
+    if (rcData[YAW]  > MAXCHECK && rcData[PITCH] > MAXCHECK) LCD = 2; // exit without save: eeprom has only 100.000 write cycles
   }
   #if defined(LCD_TEXTSTAR)
     blinkLED(20,30,1);
     LCDprint(0x0c); //clear screen
-    LCDprintChar("Saving Settings...");
+    if ( LCD == 0) LCDprintChar("Saving Settings.."); else LCDprintChar("skipping Save.");
   #endif
-  writeParams();
+  if ( LCD == 0) writeParams();
   #if defined(LCD_TEXTSTAR)
     LCDprintChar("..done! Exit.");
+    delay(1000);
   #else
     Serial.begin(SERIAL_COM_SPEED);
   #endif
@@ -1729,17 +1859,21 @@
   }
 }
 
+/* need this global to have access in serial monitor */
+static uint32_t vbatRaw = 0;       //used for smoothing voltage reading
+  
 void annexCode() { //this code is excetuted at each loop and won't interfere with control loop if it lasts less than 650 microseconds
-  static uint32_t serialTime;
-  static uint32_t buzzerTime;
+  static uint32_t serialTime = 0; // need to preset JS
+  static uint32_t buzzerTime = 0; // need to preset JS
   static uint32_t calibrateTime;
   static uint32_t calibratedAccTime;
   static uint8_t  buzzerState = 0;
-  static uint32_t vbatRaw = 0;       //used for smoothing voltage reading
   static uint8_t buzzerFreq;         //delay between buzzer ring
   uint8_t axis;
   uint8_t prop1,prop2;
-
+ #ifdef LCD_TELEMETRY_AUTO
+  static uint32_t telemetryTime = 0;
+ #endif
   for(axis=0;axis<2;axis++) {
     //PITCH & ROLL dynamic PID adjustemnt, depending on stick deviation
     prop1 = 100-min(abs(rcData[axis]-1500)/5,100)*rollPitchRate/100;
@@ -1760,9 +1894,19 @@
     vbatRaw = (vbatRaw*15 + analogRead(V_BATPIN)*16)>>4; // smoothing of vbat readings  
     vbat = vbatRaw / VBATSCALE;                          // result is Vbatt in 0.1V steps
      
-    if (vbat>VBATLEVEL1_3S) {
+    if ( (vbat>VBATLEVEL1_3S) 
+    #if defined(POWERMETER)
+                         && ( (pMeter[6] < pAlarm) || (pAlarm == 0) )
+    #endif
+                                                                        )
+    {                                          //VBAT ok AND powermeter ok, buzzer off
       buzzerFreq = 0; buzzerState = 0; BUZZERPIN_OFF;
-    } else if (vbat>VBATLEVEL2_3S)
+    }
+    #if defined(POWERMETER)
+    else if (pMeter[6] > pAlarm)                              // sound alarm for powermeter
+      buzzerFreq = 6;
+    #endif
+    else if (vbat>VBATLEVEL2_3S)
       buzzerFreq = 1;
     else if (vbat>VBATLEVEL3_3S)
       buzzerFreq = 2;
@@ -1797,6 +1941,13 @@
     serialCom();
     serialTime = currentTime;
   }
+  #ifdef LCD_TELEMETRY_AUTO
+  if ( (telemetry_auto) && (currentTime > telemetryTime + LCD_TELEMETRY_AUTO) ) { // 2 seconds
+    telemetry++;
+    if ( (telemetry < 'A' ) || (telemetry > 'D' ) ) telemetry = 'A';
+    telemetryTime = currentTime;
+  }
+  #endif
   for(axis=0;axis<2;axis++)
     rcCommand[axis]   = (rcHysteresis[axis]-MIDRC) * (rcFactor2 + rcFactor1*square((rcHysteresis[axis]-MIDRC)));
   rcCommand[THROTTLE] = (MAXTHROTTLE-MINTHROTTLE)/(2000.0-MINCHECK) * (rcHysteresis[THROTTLE]-MINCHECK) + MINTHROTTLE;
@@ -1854,6 +2005,10 @@
     calibratingA = 0;
   #endif
   calibratingG = 400;
+  #if defined(POWERMETER)
+  for(uint8_t i=0;i<7;i++) // 6 is the maximum number of possible motors, array is larger by one to append the sum
+    pMeter[i]=0; // initialize all counters
+  #endif
 }
 
 // ******** Main Loop *********
@@ -1876,6 +2031,11 @@
   static uint8_t camState = 0;
   static uint32_t camTime,magTime;
   static uint8_t rcOptions;
+  #if defined(POWERMETER)
+  uint32_t amp;
+  /* true cubic function; when divided by vbat_max=126 (12.6V) for 3 cell battery this gives maximum value of ~ 1000 */
+  const uint32_t amperes[16] =   {31, 246, 831, 1969, 3845, 6645, 10551, 15750, 22425, 30762, 40944, 53156, 67583, 84410, 103821, 126000 };
+  #endif
 
   if (currentTime > (rcTime + 20000) ) { // 50Hz
     computeRC();
@@ -1923,6 +2083,16 @@
           #endif
           previousTime = micros();
         }
+     #ifdef LCD_TELEMETRY_AUTO
+      } else if (rcData[ROLL] < MINCHECK && rcData[PITCH] > MAXCHECK && armed == 0) {
+        if (rcDelayCommand == 20) {
+           if (telemetry_auto) {
+              telemetry_auto = 0;
+              telemetry = 0;
+           } else
+              telemetry_auto = 1;
+        }
+     #endif
       } else {
         rcDelayCommand = 0;
       }
@@ -1942,6 +2112,12 @@
         rcDelayCommand = 0;
       }
     }
+    #ifdef LOG_VALUES
+      else if (armed) { // update min and max values here, so do not get cycle time of the motor arming (which is way higher than normal)
+        if (cycleTime > cycleTimeMax) cycleTimeMax = cycleTime; // remember highscore
+        if (cycleTime < cycleTimeMin) cycleTimeMin = cycleTime; // remember lowscore
+      }
+    #endif
     rcOptions = (rcData[AUX1]<1300) + (1300<rcData[AUX1] && rcData[AUX1]<1700)*2 + (rcData[AUX1]>1700)*4
                +(rcData[AUX2]<1300)*8 + (1300<rcData[AUX2] && rcData[AUX2]<1700)*16 + (rcData[AUX2]>1700)*32;
     //note: if FAILSAFE is disable, failsafeCnt > 5*FAILSAVE_DELAY is always false
@@ -2040,9 +2216,9 @@
     servo[1]  = constrain(1500 + YAW_DIRECTION * (axisPID[YAW] - axisPID[PITCH]), 1020, 2000); //RIGHT
   #endif
   #ifdef TRI
-    motor[0] = rcCommand[THROTTLE] + axisPID[PITCH]*4/3 ;                 //REAR
-    motor[1] = rcCommand[THROTTLE] - axisPID[ROLL] - axisPID[PITCH]*2/3 ; //RIGHT
-    motor[2] = rcCommand[THROTTLE] + axisPID[ROLL] - axisPID[PITCH]*2/3 ; //LEFT
+    motor[0] = rcCommand[THROTTLE] + axisPID[PITCH]*4/6 ;                 //REAR
+    motor[1] = rcCommand[THROTTLE] - axisPID[ROLL] - axisPID[PITCH]/6 ; //RIGHT
+    motor[2] = rcCommand[THROTTLE] + axisPID[ROLL] - axisPID[PITCH]/6 ; //LEFT
     servo[0] = constrain(TRI_YAW_MIDDLE + YAW_DIRECTION * axisPID[YAW], TRI_YAW_CONSTRAINT_MIN, TRI_YAW_CONSTRAINT_MAX); //REAR
   #endif
   #ifdef QUADP
@@ -2152,6 +2328,18 @@
   #endif
   
   writeMotors();
+  
+  #if defined(POWERMETER)
+  if (vbat) { // by all means - must avoid division by zero 
+    for (uint8_t i =0;i<NUMBER_MOTOR;i++) {
+
+      amp = amperes[(motor[i] - 1000)>>6] / vbat; // range mapped from [1000:2000] => [0:1000]; then break that up into 16 ranges; lookup amp
+      pMeter[i]+= amp; // sum up over time the mapped ESC input 
+                               // this is poor man's integral
+      pMeter[6]+= amp; // total sum over all motors
+    }
+  }
+  #endif
 }
 
 static uint8_t point;
@@ -2180,11 +2368,129 @@
 void serialCom() {
   int16_t a;
   uint8_t i;
+  uint16_t intPowerMeterSum, intPowerTrigger1;    
+#ifdef LCD_TELEMETRY
+#define LCD_BAR(n,v) { LCDprint(0xFE);LCDprint('b');LCDprint(n);LCDprint(v); } // n number of chars for width, v value in % to display
+  char line1[17],line2[17];
+
+  switch (telemetry) { // output telemetry data, if one of four modes is set
+  case 'A': // button A on Textstar LCD -> cycle time
+    strcpy(line1,"Cycle    _____us"); //uin16_t cycleTime
+    /*            0123456789.12345*/
+    strcpy(line2,"[_____, _____]us"); //uin16_t cycleTimeMax
+    line1[9] = '0' + cycleTime / 10000;
+    line1[10] = '0' + cycleTime / 1000 - (cycleTime/10000) * 10;
+    line1[11] = '0' + cycleTime / 100  - (cycleTime/1000)  * 10;
+    line1[12] = '0' + cycleTime / 10   - (cycleTime/100)   * 10;
+    line1[13] = '0' + cycleTime        - (cycleTime/10)    * 10;
+  #ifdef LOG_VALUES
+    line2[1] = '0' + cycleTimeMin / 10000;
+    line2[2] = '0' + cycleTimeMin / 1000 - (cycleTimeMin/10000) * 10;
+    line2[3] = '0' + cycleTimeMin / 100  - (cycleTimeMin/1000)  * 10;
+    line2[4] = '0' + cycleTimeMin / 10   - (cycleTimeMin/100)   * 10;
+    line2[5] = '0' + cycleTimeMin        - (cycleTimeMin/10)    * 10;
+    line2[8] = '0' + cycleTimeMax / 10000;
+    line2[9] = '0' + cycleTimeMax / 1000 - (cycleTimeMax/10000) * 10;
+    line2[10] = '0' + cycleTimeMax / 100  - (cycleTimeMax/1000)  * 10;
+    line2[11] = '0' + cycleTimeMax / 10   - (cycleTimeMax/100)   * 10;
+    line2[12] = '0' + cycleTimeMax        - (cycleTimeMax/10)    * 10;
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+  #endif
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    break;
+  case 'B': // button B on Textstar LCD -> Voltage, PowerSum and power alarm trigger value
+    strcpy(line1,"__._V   _____mAh"); //uint8_t vbat, intPowerMeterSum
+    /*            0123456789.12345*/
+    //strcpy(line2,".......  ......."); // intPowerMeterSum, intPowerTrigger1
+  #ifdef VBAT
+    line1[0] = '0'+vbat/100; line1[1] = '0'+vbat/10-(vbat/100)*10; line1[3] = '0'+vbat-(vbat/10)*10;
+  #endif
+  #ifdef POWERMETER
+    intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+    line1[8] = '0' + intPowerMeterSum / 10000;
+    line1[9] = '0' + intPowerMeterSum / 1000 - (intPowerMeterSum/10000) * 10;
+    line1[10] = '0' + intPowerMeterSum / 100  - (intPowerMeterSum/1000)  * 10;
+    line1[11] = '0' + intPowerMeterSum / 10   - (intPowerMeterSum/100)   * 10;
+    line1[12] = '0' + intPowerMeterSum        - (intPowerMeterSum/10)    * 10;
+    //line2[13] = '0'+powerTrigger1/100; line2[14] = '0'+powerTrigger1/10-(powerTrigger1/100)*10; line2[15] = '0'+powerTrigger1-(powerTrigger1/10)*10;
+  #endif
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    LCDprint(0xFE);LCDprint('L');LCDprint(2); //position on line 2 of LCD
+  #ifdef VBAT
+    LCD_BAR(7, (((vbat-VBATLEVEL1_3S)*100)/VBATREF) );
+    LCDprintChar("  ");
+  #endif
+  #ifdef POWERMETER  
+    if (powerTrigger1)
+       LCD_BAR(7, (intPowerMeterSum/powerTrigger1) ); // bar graph powermeter (omitted /100*PLEVELSCALE because ==1)
+  #endif
+    break;
+  case 'D': // button D on Textstar LCD -> angles 
+    uint16_t unit;
+    strcpy(line1,"DegX  ___._ ");
+    /*            0123456789.12345*/
+    strcpy(line2,"DegY  ___._ ");
+    if (angle[0] < 0 ) {
+      unit = -angle[0];
+      line1[5] = '-';
+    } else 
+      unit = angle[0];
+    //line1[5] = '0' + unit / 10000;
+    line1[6] = '0' + unit / 1000; //- (unit/10000) * 10;
+    line1[7] = '0' + unit / 100  - (unit/1000)  * 10;
+    line1[8] = '0' + unit / 10   - (unit/100)   * 10;
+    line1[10] = '0' + unit       - (unit/10)    * 10;
+    if (angle[1] < 0 ) {
+      unit = -angle[1];
+      line2[5] = '-';
+    } else 
+      unit = angle[1];
+    //line2[5] = '0' + unit / 10000;
+    line2[6] = '0' + unit / 1000; //- (unit/10000) * 10;
+    line2[7] = '0' + unit / 100  - (unit/1000)  * 10;
+    line2[8] = '0' + unit / 10   - (unit/100)   * 10;
+    line2[10] = '0' + unit       - (unit/10)    * 10;
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar(line1); //refresh line 1 of LCD
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar(line2); //refresh line 2 of LCD
+    break;      
+  case 'C': // button C on Textstar LCD 
+#define GYROLIMIT 30
+#define ACCLIMIT 40
+    LCDprint(0xFE);LCDprint('L');LCDprint(1);LCDprintChar("G "); //refresh line 1 of LCD
+    if (abs(gyroData[0]) < GYROLIMIT) { LCD_BAR(4,(abs(gyroData[0])*100/GYROLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+    if (abs(gyroData[1]) < GYROLIMIT) { LCD_BAR(4,(abs(gyroData[1])*100/GYROLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+    if (abs(gyroData[2]) < GYROLIMIT) { LCD_BAR(4,(abs(gyroData[2])*100/GYROLIMIT)) } else LCDprintChar("....");
+    LCDprint(0xFE);LCDprint('L');LCDprint(2);LCDprintChar("A "); //refresh line 2 of LCD
+    if (abs(accSmooth[0]) < ACCLIMIT) { LCD_BAR(4,(abs(accSmooth[0])*100/ACCLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+    if (abs(accSmooth[1]) < ACCLIMIT) { LCD_BAR(4,(abs(accSmooth[1])*100/ACCLIMIT)) } else LCDprintChar("...."); LCDprint(' ');
+    if (abs(accSmooth[2] - acc_1G) < ACCLIMIT) { LCD_BAR(4,(abs(accSmooth[2]-acc_1G)*100/ACCLIMIT)) } else LCDprintChar("....");
+    break; 
+}
+#endif
   if (Serial.available()) {
     switch (Serial.read()) {
-    case 'A': //arduino to GUI all data
+    #ifdef LCD_TELEMETRY
+      case 'A': // button A press
+      if (telemetry=='A') telemetry = 0; else { telemetry = 'A'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'B': // button B press
+      if (telemetry=='B') telemetry = 0; else { telemetry = 'B'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'C': // button C press
+      if (telemetry=='C') telemetry = 0; else { telemetry = 'C'; LCDprint(12); /* clear screen */ }
+      break;    
+      case 'D': // button D press
+      if (telemetry=='D') telemetry = 0; else { telemetry = 'D'; LCDprint(12); /* clear screen */ }
+      break;
+      case 'a': // button A release
+      case 'b': // button B release
+      case 'c': // button C release
+      case 'd': // button D release
+      break;      
+    #endif
+      case 'M': // Multiwii @ arduino to GUI all data
       point=0;
-      serialize8('A');
+      serialize8('M');
       for(i=0;i<3;i++) serialize16(accSmooth[i]);
       for(i=0;i<3;i++) serialize16(gyroData[i]); //12
       serialize16(altitudeSmooth);
@@ -2224,7 +2530,18 @@
       serialize8(dynThrPID);
       serialize8(activateAcc8);serialize8(activateBaro8);serialize8(activateMag8);//80
       serialize8(activateCamStab8);serialize8(activateCamTrig8);//82
-      serialize8('A');
+
+      #if defined(POWERMETER)
+      intPowerMeterSum = (pMeter[6]/PLEVELDIV);
+      intPowerTrigger1 = powerTrigger1 * PLEVELSCALE;
+      #else
+      intPowerMeterSum = 0;  
+      intPowerTrigger1 = 0;   
+      #endif    
+      serialize16(intPowerMeterSum);  
+      serialize16(intPowerTrigger1);
+      serialize8(vbat);
+      serialize8('M');
       Serial.write(s,point);
       break;
     case 'O':  // arduino to OSD data - contribution from MIS
@@ -2244,8 +2561,8 @@
       serialize8('O'); //49
       UartSendData();
       break;
-    case 'C': //GUI to arduino param
-      while (Serial.available()<21) {}
+    case 'E': //GUI write params to eeprom @ arduino
+      while (Serial.available()<23) {}
       for(i=0;i<3;i++) {P8[i]= Serial.read(); I8[i]= Serial.read(); D8[i]= Serial.read();}
       PLEVEL8 = Serial.read(); ILEVEL8 = Serial.read();
       rcRate8 = Serial.read(); rcExpo8 = Serial.read();
@@ -2253,11 +2570,21 @@
       dynThrPID = Serial.read();
       activateAcc8 = Serial.read();activateBaro8 = Serial.read();activateMag8 = Serial.read();
       activateCamStab8 = Serial.read();activateCamTrig8 = Serial.read();
+     #if defined(POWERMETER)
+      powerTrigger1 = (Serial.read() + 256* Serial.read() ) / PLEVELSCALE; // we rely on writeParams() to compute corresponding pAlarm value
+     #else
+      Serial.read();
+      Serial.read(); // so we unload the two bytes
+     #endif
       writeParams();
       break;
-    case 'D': //GUI to arduino calibration request
+    case 'S': //GUI to arduino Sensor calibration request
       calibratingA=400;
       break;
+/*    default:
+        blinkLED(20,30,1);
+        break;
+*/
     }
   }
-}
+}
