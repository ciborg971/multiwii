--- /Volumes/Vault/Users/js/Documents/RC-Heli/TriWiiCopter/01_Firmware/MultiWii_dev20110607/MultiWii_dev20110607/MultiWii_dev20110607.pde	2011-06-07 23:53:22.000000000 +0200
+++ MultiWii_dev20110607_plus_TRI40.pde	2011-06-11 14:28:56.000000000 +0200
@@ -1,4 +1,12 @@
 /*
++++++++++++++++++++
++ LCD abort
++ LCD menu wrap around
++ LCD_TELEMETRY (and redefinition for GUI command chars)
++ POWERMETER
++ FreeIMU adaption with configurable address
+*/
+/*
 MultiWiiCopter by Alexandre Dubus
 www.multiwii.com
 June  2011     V1.dev
@@ -9,9 +17,15 @@
 */
 
 #include "config.h"
+
 #include <EEPROM.h>
 #define   VERSION                    18
 
+//#include "TRI40.h"
+#if defined(INTERNAL_I2C_PULLUPS) && ( FREEIMU == 01 )
+      #error "for freeimu v0.1 from fax8/Fabio Varesano, you MUST undefine internal i2c pullups. Else you destroy board!"
+#endif
+
 #if defined(PROMINI)
   #define LEDPIN_PINMODE             pinMode (13, OUTPUT);
   #define LEDPIN_SWITCH              PINB |= 1<<5;     //switch LEDPIN state (digital PIN 13)
@@ -134,6 +148,10 @@
 static uint32_t currentTime = 0;
 static uint32_t previousTime = 0;
 static uint16_t cycleTime = 0;     // this is the number in micro second to achieve a full loop, it can differ a little and is taken into account in the PID loop
+#ifdef LOG_VALUES
+static uint16_t cycleTimeMax = 0;          // highest ever cycle timen 
+static uint16_t cycleTimeMin = 65535;          // lowest ever cycle timen 
+#endif
 static uint16_t calibratingA = 0;  // the calibration is done is the main loop. Calibrating decreases at each cycle down to 0, then we enter in a normal mode.
 static uint16_t calibratingG;
 static uint8_t armed = 0;
@@ -151,6 +169,33 @@
 static uint8_t okToArm = 0;
 static uint8_t rcOptions;
 
+static uint32_t pMeter[7]; //we use [0:5] for six motors,[6] for sum
+static uint8_t pMeterV; // dummy to satisfy the paramStruct logic in ConfigurationLoop()
+static uint32_t pAlarm; // we scale the eeprom value from [0:255] to this value we can directly compare to the sum in pMeter[6]
+static uint8_t powerTrigger1 = 0; // trigger for alarm based on power consumption
+#if defined(POWERMETER)
+#ifndef VBAT
+	#error "to use powermeter, you must also define and configure VBAT"
+#endif
+#define PARAMMAX 29
+#define PARAMMOTORSTART  20
+#define PARAMMOTOREND    28
+#define PARAMMOTOROFFSET 21
+#else
+#define PARAMMAX 20
+#endif
+
+#ifdef LCD_TELEMETRY
+static uint8_t telemetry = 0;
+#endif
+#ifdef LCD_TELEMETRY_AUTO
+  #ifndef LCD_TELEMETRY
+     #error "to use automatic telemetry, you MUST also define and configure LCD_TELEMETRY"
+  #endif
+static uint8_t telemetry_auto = 0;
+#endif
+
+
 #if defined(ADXL345) || defined(BMA020) || defined(BMA180) || defined(NUNCHACK) || defined(ADCACC)
   #define ACC 1
 #else
@@ -223,7 +268,7 @@
   uint8_t  increment;
 } paramStruct;
 
-static paramStruct param[21] = {
+static paramStruct param[30] = {
   {"PITCH&ROLL P", &P8[ROLL],1,1},
   {"ROLL   P", &P8[ROLL],1,1},     {"ROLL   I", &I8[ROLL],3,5},  {"ROLL   D", &D8[ROLL],0,1},
   {"PITCH  P", &P8[PITCH],1,1},    {"PITCH  I", &I8[PITCH],3,5}, {"PITCH  D", &D8[PITCH],0,1},
@@ -234,6 +279,16 @@
   {"RC RATE", &rcRate8,2,2},       {"RC EXPO", &rcExpo8,2,2},
   {"PITCH&ROLL RATE", &rollPitchRate,2,2}, {"YAW RATE", &yawRate,2,2},
   {"THROTTLE PID", &dynThrPID,2,2},
+
+  {"pMeter Motor 0", &pMeterV,16,0}, // 21
+  {"pMeter Motor 1", &pMeterV,16,0},
+  {"pMeter Motor 2", &pMeterV,16,0},
+  {"pMeter Motor 3", &pMeterV,16,0},
+  {"pMeter Motor 4", &pMeterV,16,0},
+  {"pMeter Motor 5", &pMeterV,16,0},
+  {"pMeter Sum", &pMeterV,16,0},
+  {"pAlarm /50", &powerTrigger1,0,1}, // change text to represent PLEVELSCALE value
+  {"Battery Volt", &vbat,1,0}, //29
 };
 
 void blinkLED(uint8_t num, uint8_t wait,uint8_t repeat) {
@@ -256,7 +311,9 @@
   static uint8_t buzzerFreq;         //delay between buzzer ring
   uint8_t axis;
   uint8_t prop1,prop2;
-
+ #ifdef LCD_TELEMETRY_AUTO
+  static uint32_t telemetryTime = 0;
+ #endif
   //PITCH & ROLL only dynamic PID adjustemnt,  depending on throttle value
   if      (rcData[THROTTLE]<1500) prop2 = 100;
   else if (rcData[THROTTLE]<2000) prop2 = 100 - (rcData[THROTTLE]-1500)/5 * dynThrPID/100;
@@ -278,8 +335,17 @@
     vbatRaw = (vbatRaw*15 + analogRead(V_BATPIN)*16)>>4; // smoothing of vbat readings  
     vbat = vbatRaw / VBATSCALE;                  // result is Vbatt in 0.1V steps
      
-    if (vbat>VBATLEVEL1_3S) {
+    if ( (vbat>VBATLEVEL1_3S) 
+    #if defined(POWERMETER)
+                         && ( (pMeter[6] < pAlarm) || (pAlarm == 0) )
+    #endif
+                                                                        )
+    {                                          //VBAT ok AND powermeter ok, buzzer off
       buzzerFreq = 0; buzzerState = 0; BUZZERPIN_OFF;
+    #if defined(POWERMETER)
+    } else if (pMeter[6] > pAlarm) {                             // sound alarm for powermeter
+      buzzerFreq = 4;
+    #endif
     } else if (vbat>VBATLEVEL2_3S)
       buzzerFreq = 1;
     else if (vbat>VBATLEVEL3_3S)
@@ -314,7 +380,13 @@
     serialCom();
     serialTime = micros();
   }
-  
+ #ifdef LCD_TELEMETRY_AUTO
+  if ( (telemetry_auto) && (micros() > telemetryTime + LCD_TELEMETRY_AUTO) ) { // every 2 seconds
+    telemetry++;
+    if ( (telemetry < 'A' ) || (telemetry > 'D' ) ) telemetry = 'A';
+    telemetryTime = micros(); // why use micros() and not the variable currentTime ?
+  }
+ #endif  
   for(axis=0;axis<2;axis++) {
     uint16_t tmp = abs(rcData[axis]-MIDRC);
     uint16_t tmp2 = tmp/100;
@@ -344,6 +416,10 @@
    calibratingA = 400;
   #endif
   calibratingG = 400;
+  #if defined(POWERMETER)
+  for(uint8_t i=0;i<7;i++) // 6 is the maximum number of possible motors, array is larger by one to append the sum
+    pMeter[i]=0;
+  #endif
 }
 
 // ******** Main Loop *********
@@ -402,6 +478,16 @@
         if (rcDelayCommand == 20) armed = 0; // rcDelayCommand = 20 => 20x20ms = 0.4s = time to wait for a specific RC command to be acknowledged
       } else if ( (rcData[YAW] > MAXCHECK || rcData[ROLL] > MAXCHECK) && rcData[PITCH] < MAXCHECK && armed == 0 && calibratingG == 0 && calibratedACC == 1) {
         if (rcDelayCommand == 20) armed = 1;
+     #ifdef LCD_TELEMETRY_AUTO
+      } else if (rcData[ROLL] < MINCHECK && rcData[PITCH] > MAXCHECK && armed == 0) {
+        if (rcDelayCommand == 20) {
+           if (telemetry_auto) {
+              telemetry_auto = 0;
+              telemetry = 0;
+           } else
+              telemetry_auto = 1;
+        }
+     #endif
       } else
         rcDelayCommand = 0;
     } else if (rcData[THROTTLE] > MAXCHECK && armed == 0) {
@@ -420,6 +506,12 @@
         rcDelayCommand = 0;
       }
     }
+   #ifdef LOG_VALUES
+    else if (armed) { // update min and max values here, so do not get cycle time of the motor arming (which is way higher than normal)
+      if (cycleTime > cycleTimeMax) cycleTimeMax = cycleTime; // remember highscore
+      if (cycleTime < cycleTimeMin) cycleTimeMin = cycleTime; // remember lowscore
+    }
+   #endif
     rcOptions = (rcData[AUX1]<1300)   + (1300<rcData[AUX1] && rcData[AUX1]<1700)*2  + (rcData[AUX1]>1700)*4
                +(rcData[AUX2]<1300)*8 + (1300<rcData[AUX2] && rcData[AUX2]<1700)*16 + (rcData[AUX2]>1700)*32;
     
@@ -561,6 +653,10 @@
   mixTable();
   writeServos();
   writeMotors();
+  #if defined(POWERMETER)
+  logMotorsPower();
+  #endif  
+
 }
 
-
+
